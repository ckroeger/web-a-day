<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Progress Pie Final</title>
    <style>
        :root {
            --primary: #4f46e5;
            --bg: #f8fafc; /* Etwas hellerer Hintergrund für besseren Kontrast zum Chart */
            --card: #ffffff;
            --text: #1e293b;
            --empty-segment: #eaecf0; /* Helles Grau für den Hintergrund-Teil */
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 30px;
            display: flex;
            justify-content: center;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            max-width: 1100px;
            width: 100%;
            background: var(--card);
            padding: 40px;
            border-radius: 24px;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.1);
        }

        @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }

        /* --- Inputs Styling --- */
        .form-group { margin-bottom: 25px; }
        label { display: block; margin-bottom: 8px; font-weight: 700; color: #475569; font-size: 0.9rem; }
        
        #theme-input {
            width: 100%; padding: 14px; font-size: 1.1rem;
            border: 2px solid #e2e8f0; border-radius: 12px;
            box-sizing: border-box; transition: all 0.2s;
            background: #f8fafc;
        }
        #theme-input:focus { border-color: var(--primary); background: #fff; outline: none; }

        .row { display: flex; gap: 10px; margin-bottom: 10px; align-items: center; animation: slideIn 0.2s ease-out; }
        .row input {
            padding: 12px; border: 1px solid #e2e8f0; border-radius: 10px;
            font-size: 0.95rem; transition: border-color 0.2s;
        }
        .row input:focus { border-color: var(--primary); outline: none; }
        .row input[type="text"] { flex: 3; }
        .row input[type="number"] { flex: 1; text-align: center; }
        .btn-delete {
            background: #fee2e2; color: #ef4444; border: none;
            width: 36px; height: 36px; border-radius: 50%;
            font-size: 1.2rem; cursor: pointer; display: flex;
            align-items: center; justify-content: center; transition: 0.2s;
        }
        .btn-delete:hover { background: #fecaca; transform: scale(1.05); }

        .button-bar { margin-top: 25px; display: flex; flex-direction: column; gap: 15px; }
        .btn-add {
            padding: 14px; border-radius: 12px; border: 2px dashed #c7d2fe;
            background: #eef2ff; color: var(--primary); font-weight: 700;
            cursor: pointer; transition: all 0.2s;
        }
        .btn-add:hover { background: #e0e7ff; border-color: var(--primary); }
        
        details { background: #f8fafc; border-radius: 12px; padding: 15px; border: 1px solid #e2e8f0; }
        summary { cursor: pointer; font-weight: 600; color: #64748b; user-select: none; }
        #bulk-input {
            width: 100%; height: 120px; margin-top: 15px; padding: 12px;
            font-family: monospace; border: 1px solid #cbd5e1; border-radius: 10px;
            box-sizing: border-box; resize: vertical;
        }

        /* --- Chart Styling (Neu: Schatten & Rahmen) --- */
        .chart-section {
            text-align: center; display: flex; flex-direction: column;
            align-items: center; position: sticky; top: 30px;
        }
        #chart-header {
            font-size: 1.4rem; font-weight: 800; margin-bottom: 25px;
            color: #0f172a; letter-spacing: -0.02em;
        }
        
        /* Das Herzstück des neuen Looks */
        #pie-chart {
            transform: rotate(-90deg);
            border-radius: 50%;
            background: #ffffff; /* Sorgt für saubere weiße Lücken (Rahmen) */
            border: 4px solid #ffffff; /* Weißer Innenring */
            outline: 1px solid #e2e8f0; /* Subtiler äußerer Begrenzungsring */
            /* Der "nice leichte Schatten" - mehrstufig für Weichheit */
            filter: drop-shadow(0 10px 20px rgba(0,0,0,0.12)) drop-shadow(0 4px 8px rgba(0,0,0,0.06));
            transition: all 0.3s ease;
        }
        #pie-chart:hover { transform: rotate(-90deg) scale(1.02); } /* Leichter Hover-Effekt */

        .legend {
            margin-top: 30px; display: grid; grid-template-columns: 1fr; gap: 10px;
            width: 100%; max-width: 340px;
        }
        .legend-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px 16px; background: #f8fafc; border-radius: 10px;
            font-size: 0.9rem; border-left: 5px solid transparent;
            box-shadow: 0 2px 5px rgba(0,0,0,0.03);
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .legend-item.highlighted {
            background: #e0e7ff;
            transform: translateX(5px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.2);
        }
        .legend-label { font-weight: 500; color: #334155; }
        .legend-value { font-weight: 800; font-feature-settings: "tnum"; }

        @keyframes slideIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }
    </style>
</head>
<body>

<div class="container">
    <div class="input-section">
        <div class="form-group">
            <label for="theme-input">Projekt / Thema</label>
            <input type="text" id="theme-input" value="VKPK Reporting" oninput="render()" placeholder="Name des Themas">
        </div>

        <label>Teilaspekte definieren</label>
        <div id="inputs-container"></div>

        <div class="button-bar">
            <button class="btn-add" onclick="addRow()">+ Neuen Aspekt anlegen</button>
            
            <details open>
                <summary>Schnellerfassung (Copy & Paste)</summary>
                <textarea id="bulk-input" oninput="syncFromBulk()" placeholder="Beispiel:
Analyse, 100
Konzeption, 80
Umsetzung, 40"></textarea>
            </details>
        </div>
    </div>

    <div class="chart-section">
        <div id="chart-header">Thema</div>
        <svg id="pie-chart" width="340" height="340" viewBox="-2 -2 36 36">
            </svg>
        <div id="legend" class="legend"></div>
    </div>
</div>

<script>
    // Modernere Farbpalette
    const COLORS = [
        '#4f46e5', // Indigo
        '#0ea5e9', // Sky
        '#10b981', // Emerald
        '#f59e0b', // Amber
        '#ef4444', // Red
        '#8b5cf6', // Violet
        '#ec4899', // Pink
        '#06b6d4'  // Cyan
    ];
    
    // Konfiguration für Segment-Rahmen
    const SEGMENT_BORDER_WIDTH = 0.5; // Breite des Rahmens (wird zur stroke-width addiert)
    const SEGMENT_BORDER_COLOR = '#000000'; // Farbe des Rahmens
    
    const initialRaw = "Angebot erstellen, 100\nAngebot aktualisieren, 90\nAngebot berechnen, 90\nAngebot validieren, 60\nAntragsprozess, 30\nDruck & Versand, 10";

    let currentData = []; // Globale Referenz für Event-Handler
    let lastHighlightedIndex = -1;

    function init() {
        document.getElementById('bulk-input').value = initialRaw;
        syncFromBulk();
    }

    function addRow(label = "", val = "") {
        const container = document.getElementById('inputs-container');
        if (container.children.length >= 20) { alert("Maximum von 20 Aspekten erreicht."); return; }
        const div = document.createElement('div');
        div.className = 'row';
        div.innerHTML = `
            <input type="text" placeholder="Bezeichnung" value="${label}" oninput="syncFromInputs()">
            <input type="number" placeholder="%" value="${val}" min="0" max="100" oninput="syncFromInputs()">
            <button class="btn-delete" onclick="this.parentElement.remove(); syncFromInputs();" title="Entfernen">&times;</button>
        `;
        container.appendChild(div);
        syncFromInputs();
    }

    function syncFromInputs() {
        const rows = document.querySelectorAll('.row');
        let lines = [];
        rows.forEach(row => {
            const inputs = row.querySelectorAll('input');
            // Nur übernehmen wenn Label oder Wert existiert
            if(inputs[0].value.trim() || inputs[1].value.trim()) {
                 // Wenn kein Wert, dann 0 annehmen
                const val = inputs[1].value.trim() === "" ? 0 : inputs[1].value.trim();
                lines.push(`${inputs[0].value}, ${val}`);
            }
        });
        document.getElementById('bulk-input').value = lines.join('\n');
        render();
    }

    function syncFromBulk() {
        const text = document.getElementById('bulk-input').value;
        const container = document.getElementById('inputs-container');
        container.innerHTML = '';
        
        const lines = text.split('\n');
        lines.forEach(line => {
            // Ignoriere leere Zeilen
            if(!line.trim()) return;

            // Flexibler Split, falls Komma im Namen vorkommt (nimmt das letzte Komma als Trenner)
            const lastCommaIndex = line.lastIndexOf(',');
            let label, val;

            if (lastCommaIndex > -1) {
                 label = line.substring(0, lastCommaIndex).trim();
                 val = line.substring(lastCommaIndex + 1).trim();
            } else {
                 label = line.trim();
                 val = "0";
            }
            
            if(label) {
                const div = document.createElement('div');
                div.className = 'row';
                // Stelle sicher, dass val eine Zahl ist, sonst leer
                const numericVal = isNaN(parseFloat(val)) ? '' : parseFloat(val);

                div.innerHTML = `
                    <input type="text" placeholder="Bezeichnung" value="${label}" oninput="syncFromInputs()">
                    <input type="number" placeholder="%" value="${numericVal}" min="0" max="100" oninput="syncFromInputs()">
                    <button class="btn-delete" onclick="this.parentElement.remove(); syncFromInputs();">&times;</button>
                `;
                container.appendChild(div);
            }
        });
        render();
    }

    function render() {
        const theme = document.getElementById('theme-input').value || "Projektauswertung";
        const rows = document.querySelectorAll('.row');
        const data = [];
        let totalVal = 0;

        rows.forEach(row => {
            const inputs = row.querySelectorAll('input');
            const l = inputs[0].value.trim();
            // Sicherstellen, dass der Wert zwischen 0 und 100 liegt
            let v = parseFloat(inputs[1].value) || 0;
            v = Math.max(0, Math.min(100, v)); 

            if (l) {
                data.push({ label: l, val: v });
                totalVal += v;
            }
        });

        currentData = data; // Speichere für Event-Handler

        const n = data.length;
        const maxSum = n * 100;
        // Header mit Durchschnitt statt Summe (optional, oft aussagekräftiger)
        const avg = n > 0 ? Math.round(totalVal / n) : 0;
        document.getElementById('chart-header').innerHTML = `${theme} <span style="color:var(--primary); font-size:0.9em">(${(avg)}% Ø)</span>`;

        const svg = document.getElementById('pie-chart');
        const legend = document.getElementById('legend');
        svg.innerHTML = '';
        legend.innerHTML = '';

        if (n === 0) {
             // Platzhalter, wenn keine Daten
             svg.innerHTML = '<circle r="16" cx="16" cy="16" fill="none" stroke="#e2e8f0" stroke-width="32" />';
             return;
        }

        const sliceSize = 100 / n;
        // GAP ERHÖHT: Sorgt für dickere weiße "Rahmen" zwischen den Stücken
        const gap = n > 1 ? 0.19 : 0;
        // Korrigierte Berechnung: Größe jedes Segments ohne Gap
        const segmentSize = sliceSize - gap;
        // Gesamtumfang minus alle Gaps
        const totalCircumference = 100;

        data.forEach((item, i) => {
            const color = COLORS[i % COLORS.length];
            const offset = -(i * sliceSize + gap / 2);

            const segmentGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            segmentGroup.dataset.segmentIndex = i; // Markiere die Gruppe

            if (SEGMENT_BORDER_WIDTH > 0) {
                const borderArc = createArc(segmentSize, offset, SEGMENT_BORDER_COLOR, 32 + (SEGMENT_BORDER_WIDTH * 2));
                segmentGroup.appendChild(borderArc);
            }

            const bgColor = color + alphaHex(0.6); // 0.1 = 10% Transparenz
            const bgArc = createArc(segmentSize, offset, bgColor);
            segmentGroup.appendChild(bgArc);

            const progressSize = (item.val / 100) * segmentSize;
            
            if(progressSize > 0.1) {
                 const fgArc = createArc(progressSize, offset, color);
                 // Optional: Hellerer Schein auf dem farbigen Segment für "Glossy" Look
                 fgArc.style.filter = "drop-shadow(0 0 2px rgba(255,255,255,0.3))";
                 segmentGroup.appendChild(fgArc);
            }

            const hitArea = createArc(segmentSize, offset, 'transparent', 34);
            hitArea.style.pointerEvents = 'all';
            hitArea.style.cursor = 'pointer';
            segmentGroup.appendChild(hitArea);

            svg.appendChild(segmentGroup);

            // 4. Legende
            const li = document.createElement('div');
            li.className = 'legend-item';
            li.id = `legend-${i}`;
            li.style.borderLeftColor = color;
            li.innerHTML = `<span class="legend-label">${item.label}</span> <span class="legend-value" style="color:${color}">${item.val}%</span>`;
            li.addEventListener('mouseenter', () => highlightSegment(i));
            li.addEventListener('mouseleave', () => unhighlightSegment(i));
            legend.appendChild(li);
        });

        // Event-Delegation auf SVG-Ebene
        svg.onmousemove = handleSvgMouseMove;
        svg.onmouseleave = handleSvgMouseLeave;
    }

    function createArc(size, offset, color, strokeWidth = 32) {
        size = Math.max(0, size);
        
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("r", "16");
        circle.setAttribute("cx", "16");
        circle.setAttribute("cy", "16");
        circle.setAttribute("fill", "transparent");
        circle.setAttribute("stroke", color);
        circle.setAttribute("stroke-width", strokeWidth.toString());
        circle.setAttribute("stroke-linecap", "butt"); 
        circle.setAttribute("stroke-dasharray", `${size} 100`);
        circle.setAttribute("stroke-dashoffset", offset);
        circle.style.transition = "stroke-dasharray 0.6s cubic-bezier(0.25, 0.8, 0.25, 1), stroke 0.3s";
        circle.style.pointerEvents = 'none';
        
        return circle;
    }

    function highlightSegment(index) {
        const legendItem = document.getElementById(`legend-${index}`);
        if (legendItem) {
            legendItem.classList.add('highlighted');
        }
    }

    function unhighlightSegment(index) {
        const legendItem = document.getElementById(`legend-${index}`);
        if (legendItem) {
            legendItem.classList.remove('highlighted');
        }
    }

    function handleSvgMouseMove(e) {
        const svg = document.getElementById('pie-chart');
        const rect = svg.getBoundingClientRect();
        const x = e.clientX - rect.left - rect.width / 2;
        const y = e.clientY - rect.top - rect.height / 2;
        
        // Berechne Winkel (0° = oben, im Uhrzeigersinn)
        let angle = Math.atan2(y, x) * (180 / Math.PI) + 90;
        if (angle < 0) angle += 360;
        
        // Berechne welches Segment
        const n = currentData.length;
        const sliceSize = 360 / n;
        const segmentIndex = Math.floor(angle / sliceSize);
        
        if (segmentIndex !== lastHighlightedIndex && segmentIndex >= 0 && segmentIndex < n) {
            if (lastHighlightedIndex >= 0) {
                unhighlightSegment(lastHighlightedIndex);
            }
            highlightSegment(segmentIndex);
            lastHighlightedIndex = segmentIndex;
        }
    }

    function handleSvgMouseLeave() {
        if (lastHighlightedIndex >= 0) {
            unhighlightSegment(lastHighlightedIndex);
            lastHighlightedIndex = -1;
        }
    }

    // Wandelt einen Wert von 0.0 bis 1.0 in einen zweistelligen Hex-Alpha-Wert um
    /*
    Die Werte für die gewünschten Prozentsätze (Alpha) lauten:
        10 % → 1A
        20 % → 33
        30 % → 4D
        40 % → 66
        50 % → 80
        60 % → 99
    
        Berechnung:
        Alpha-Hex=round(255×Prozent/100)
    
        Das Ergebnis wird als zweistellige Hex-Zahl geschrieben.
    */
    function alphaHex(percent) {
        // Clamp zwischen 0 und 1
        percent = Math.max(0, Math.min(1, percent));
        const hex = Math.round(percent * 255).toString(16).toUpperCase();
        return hex.length === 1 ? '0' + hex : hex;
    }

    init();
</script>

</body>
</html>